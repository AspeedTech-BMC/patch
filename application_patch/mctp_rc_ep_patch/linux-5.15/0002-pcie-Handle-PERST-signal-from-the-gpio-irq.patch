From ed24b5c3b50196aec3cab488fc1a985be44b4fdb Mon Sep 17 00:00:00 2001
From: ryan_chen <ryan_chen@aspeedtech.com>
Date: Mon, 7 Mar 2022 10:10:09 +0800
Subject: [PATCH 2/3] pcie: Handle PERST signal from the gpio irq.

This patch will use the gpio to connect with the EP PERST. When the gpio
sense the GPIO falling edge irq the driver will execute the below
procedure to fix the EP/RC mctp issue:
1. Remove the devices on the RC bus
2. Toggle the RC-PERST to reset the PCIe EP and PCIe RC
3. Rescan the devices on the RC bus

The topology for MCTP EP/RC work at the same time:
                         AST2600
+------+  PERST out +---------------+
|x86 RC|----------->|GPIO(3.3v)     |
+------+            |               |
         +--------->|PERST#         |
         |          |               |
         |          |               |
         +--------->|SSPRST#        |
                    +---------------+

Signed-off-by: ryan_chen <ryan_chen@aspeedtech.com>
Change-Id: I1663c40228e1d8481ddc9268800535f45994efc5
---
 arch/arm/boot/dts/aspeed-ast2600-evb.dts |  1 +
 drivers/pci/controller/pcie-aspeed.c     | 96 ++++++++++++++++++++++++
 2 files changed, 97 insertions(+)

diff --git a/arch/arm/boot/dts/aspeed-ast2600-evb.dts b/arch/arm/boot/dts/aspeed-ast2600-evb.dts
index f3f5c1f9dd58..6a34e77e0a30 100644
--- a/arch/arm/boot/dts/aspeed-ast2600-evb.dts
+++ b/arch/arm/boot/dts/aspeed-ast2600-evb.dts
@@ -793,6 +793,7 @@ &pciecfg {
 };
 
 &pcie1 {
+	perst-gpios = <&gpio0 ASPEED_GPIO(B, 0) GPIO_ACTIVE_HIGH>;
 	status = "okay";
 };
 
diff --git a/drivers/pci/controller/pcie-aspeed.c b/drivers/pci/controller/pcie-aspeed.c
index c5274dea57ec..736f432bc560 100644
--- a/drivers/pci/controller/pcie-aspeed.c
+++ b/drivers/pci/controller/pcie-aspeed.c
@@ -17,6 +17,10 @@
 #include <linux/pci.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/gpio/consumer.h>
 
 /*	PCI Host Controller registers */
 #define ASPEED_PCIE_CLASS_CODE		0x04
@@ -107,6 +111,8 @@ struct aspeed_pcie {
 	struct mutex lock;
 	int link;
 	int hotplug_event;
+	struct gpio_desc *pe_rst;
+	struct delayed_work rst_dwork;
 	DECLARE_BITMAP(msi_irq_in_use, MAX_MSI_HOST_IRQS);
 };
 
@@ -804,6 +810,82 @@ static ssize_t hotplug_store(struct device *dev,
 
 static DEVICE_ATTR_WO(hotplug);
 
+static void aspeed_pcie_reset_work(struct work_struct *work)
+{
+	struct aspeed_pcie *pcie = container_of(work, typeof(*pcie), rst_dwork.work);
+	struct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);
+	struct pci_dev *dev;
+	u16 command;
+	u32 link_sts = 0;
+
+	pci_lock_rescan_remove();
+
+	dev = pci_get_domain_bus_and_slot(pcie->domain, 130, 0);
+	if (dev) {
+		pci_stop_and_remove_bus_device(dev);
+
+		pci_read_config_word(dev, PCI_COMMAND, &command);
+		command &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_SERR);
+		command |= PCI_COMMAND_INTX_DISABLE;
+		pci_write_config_word(dev, PCI_COMMAND, command);
+
+		pci_dev_put(dev);
+	}
+
+	dev = pci_get_domain_bus_and_slot(pcie->domain, 129, 0);
+	if (dev) {
+		pci_stop_and_remove_bus_device(dev);
+
+		pci_read_config_word(dev, PCI_COMMAND, &command);
+		command &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_SERR);
+		command |= PCI_COMMAND_INTX_DISABLE;
+		pci_write_config_word(dev, PCI_COMMAND, command);
+
+		pci_dev_put(dev);
+	}
+
+	dev = pci_get_domain_bus_and_slot(pcie->domain, 128, PCI_DEVFN(8, 0));
+	if (dev) {
+		pci_stop_and_remove_bus_device(dev);
+
+		pci_read_config_word(dev, PCI_COMMAND, &command);
+		command &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_SERR);
+		command |= PCI_COMMAND_INTX_DISABLE;
+		pci_write_config_word(dev, PCI_COMMAND, command);
+
+		pci_dev_put(dev);
+	}
+
+	reset_control_assert(pcie->phy_rst);
+	ndelay(300);
+	reset_control_deassert(pcie->phy_rst);
+	mdelay(10);
+
+
+	regmap_read(pcie->pciephy, ASPEED_PCIE_LINK, &link_sts);
+	if (link_sts & PCIE_LINK_STS) {
+		pcie->link = 1;
+		dev_info(pcie->dev, "PCIE- Link up\n");
+	} else {
+		dev_info(pcie->dev, "PCIE- Link down\n");
+		pcie->link = 0;
+	}
+
+	pci_rescan_bus(host->bus);
+	pci_unlock_rescan_remove();
+
+}
+
+static irqreturn_t pcie_rst_irq_handler(int irq, void *dev_id)
+{
+	struct aspeed_pcie *pcie = dev_id;
+
+	schedule_delayed_work(&pcie->rst_dwork,
+				  msecs_to_jiffies(1));
+
+	return IRQ_HANDLED;
+}
+
 static int aspeed_pcie_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -835,6 +917,20 @@ static int aspeed_pcie_probe(struct platform_device *pdev)
 		return err;
 	}
 
+	if (pcie->domain) {
+		printk("pcie->dev_domain %d \n", pcie->domain);
+		pcie->pe_rst = devm_gpiod_get(pcie->dev, "perst", GPIOD_IN);
+		gpiod_set_debounce(pcie->pe_rst, 100);
+		irq_set_irq_type(gpiod_to_irq(pcie->pe_rst), IRQ_TYPE_EDGE_FALLING);
+		err = devm_request_irq(pcie->dev, gpiod_to_irq(pcie->pe_rst),
+					   pcie_rst_irq_handler, IRQF_SHARED,
+					   "PERST monitor", pcie);
+		if (err) {
+			dev_err(pcie->dev, "Failed to request gpio irq %d\n", err);
+			return err;
+		}
+		INIT_DELAYED_WORK(&pcie->rst_dwork, aspeed_pcie_reset_work);
+	}
 
 	return pci_host_probe(host);
 }
-- 
2.25.1

