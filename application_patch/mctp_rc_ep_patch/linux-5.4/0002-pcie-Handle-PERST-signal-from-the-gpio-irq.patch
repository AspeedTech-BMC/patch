From dfea77a7cdf89ce0e938d47d6049d124f254d3f6 Mon Sep 17 00:00:00 2001
From: ryan_chen <ryan_chen@aspeedtech.com>
Date: Mon, 7 Mar 2022 10:10:09 +0800
Subject: [PATCH 2/3] pcie: Handle PERST signal from the gpio irq.

This patch will use the gpio to connect with the EP PERST. When the gpio
sense the GPIO falling edge irq the driver will execute the below
procedure to fix the EP/RC mctp issue:
1. Remove the devices on the RC bus
2. Toggle the RC-PERST to reset the PCIe EP and PCIe RC
3. Rescan the devices on the RC bus

The topology for MCTP EP/RC work at the same time:
                         AST2600
+------+  PERST out +---------------+
|x86 RC|----------->|GPIO(3.3v)     |
+------+            |               |
         +--------->|PERST#         |
         |          |               |
         |          |               |
         +--------->|SSPRST#        |
                    +---------------+

Signed-off-by: ryan_chen <ryan_chen@aspeedtech.com>
Change-Id: I1663c40228e1d8481ddc9268800535f45994efc5
---
 arch/arm/boot/dts/aspeed-ast2600-evb.dts |  1 +
 drivers/pci/controller/pcie-aspeed.c     | 96 ++++++++++++++++++++++++
 2 files changed, 97 insertions(+)

diff --git a/arch/arm/boot/dts/aspeed-ast2600-evb.dts b/arch/arm/boot/dts/aspeed-ast2600-evb.dts
index 5e976474d9f8..62234929ef17 100644
--- a/arch/arm/boot/dts/aspeed-ast2600-evb.dts
+++ b/arch/arm/boot/dts/aspeed-ast2600-evb.dts
@@ -828,6 +828,7 @@
 };
 
 &pcie1 {
+	perst-gpios = <&gpio0 ASPEED_GPIO(B, 0) GPIO_ACTIVE_HIGH>;
 	status = "okay";
 };
 
diff --git a/drivers/pci/controller/pcie-aspeed.c b/drivers/pci/controller/pcie-aspeed.c
index 5ea8d772d7a7..4f27c671345c 100644
--- a/drivers/pci/controller/pcie-aspeed.c
+++ b/drivers/pci/controller/pcie-aspeed.c
@@ -18,6 +18,10 @@
 #include <linux/pci.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/gpio/consumer.h>
 
 #include "../pci.h"
 
@@ -112,6 +116,8 @@ struct aspeed_pcie {
 	struct mutex lock;
 	int link;
 	int hotplug_event;
+	struct gpio_desc *pe_rst;
+	struct delayed_work rst_dwork;
 	DECLARE_BITMAP(msi_irq_in_use, MAX_MSI_HOST_IRQS);
 };
 
@@ -854,6 +860,82 @@ static ssize_t hotplug_store(struct device *dev,
 
 static DEVICE_ATTR_WO(hotplug);
 
+static void aspeed_pcie_reset_work(struct work_struct *work)
+{
+	struct aspeed_pcie *pcie = container_of(work, typeof(*pcie), rst_dwork.work);
+	struct pci_host_bridge *host = pci_host_bridge_from_priv(pcie);
+	struct pci_dev *dev;
+	u16 command;
+	u32 link_sts = 0;
+
+	pci_lock_rescan_remove();
+
+	dev = pci_get_domain_bus_and_slot(pcie->domain, 130, 0);
+	if (dev) {
+		pci_stop_and_remove_bus_device(dev);
+
+		pci_read_config_word(dev, PCI_COMMAND, &command);
+		command &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_SERR);
+		command |= PCI_COMMAND_INTX_DISABLE;
+		pci_write_config_word(dev, PCI_COMMAND, command);
+
+		pci_dev_put(dev);
+	}
+
+	dev = pci_get_domain_bus_and_slot(pcie->domain, 129, 0);
+	if (dev) {
+		pci_stop_and_remove_bus_device(dev);
+
+		pci_read_config_word(dev, PCI_COMMAND, &command);
+		command &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_SERR);
+		command |= PCI_COMMAND_INTX_DISABLE;
+		pci_write_config_word(dev, PCI_COMMAND, command);
+
+		pci_dev_put(dev);
+	}
+
+	dev = pci_get_domain_bus_and_slot(pcie->domain, 128, PCI_DEVFN(8, 0));
+	if (dev) {
+		pci_stop_and_remove_bus_device(dev);
+
+		pci_read_config_word(dev, PCI_COMMAND, &command);
+		command &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_SERR);
+		command |= PCI_COMMAND_INTX_DISABLE;
+		pci_write_config_word(dev, PCI_COMMAND, command);
+
+		pci_dev_put(dev);
+	}
+
+	reset_control_assert(pcie->phy_rst);
+	ndelay(300);
+	reset_control_deassert(pcie->phy_rst);
+	mdelay(10);
+
+
+	regmap_read(pcie->pciephy, ASPEED_PCIE_LINK, &link_sts);
+	if (link_sts & PCIE_LINK_STS) {
+		pcie->link = 1;
+		dev_info(pcie->dev, "PCIE- Link up\n");
+	} else {
+		dev_info(pcie->dev, "PCIE- Link down\n");
+		pcie->link = 0;
+	}
+
+	pci_rescan_bus(host->bus);
+	pci_unlock_rescan_remove();
+
+}
+
+static irqreturn_t pcie_rst_irq_handler(int irq, void *dev_id)
+{
+	struct aspeed_pcie *pcie = dev_id;
+
+	schedule_delayed_work(&pcie->rst_dwork,
+				  msecs_to_jiffies(1));
+
+	return IRQ_HANDLED;
+}
+
 static int aspeed_pcie_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -889,6 +971,20 @@ static int aspeed_pcie_probe(struct platform_device *pdev)
 		return err;
 	}
 
+	if (pcie->domain) {
+		printk("pcie->dev_domain %d \n", pcie->domain);
+		pcie->pe_rst = devm_gpiod_get(pcie->dev, "perst", GPIOD_IN);
+		gpiod_set_debounce(pcie->pe_rst, 100);
+		irq_set_irq_type(gpiod_to_irq(pcie->pe_rst), IRQ_TYPE_EDGE_FALLING);
+		err = devm_request_irq(pcie->dev, gpiod_to_irq(pcie->pe_rst),
+					   pcie_rst_irq_handler, IRQF_SHARED,
+					   "PERST monitor", pcie);
+		if (err) {
+			dev_err(pcie->dev, "Failed to request gpio irq %d\n", err);
+			return err;
+		}
+		INIT_DELAYED_WORK(&pcie->rst_dwork, aspeed_pcie_reset_work);
+	}
 
 	return pci_host_probe(host);
 }
-- 
2.25.1

